# ğŸ—ï¸ å…¨æ ˆæŠ€æœ¯æ¶æ„è®¾è®¡
## Web3å›ºå®šæ”¶ç›Šå¹³å°æŠ€æœ¯å®æ–½æ–¹æ¡ˆ

> **æ¶æ„ç†å¿µ**ï¼šæ„å»ºå¯æ‰©å±•ã€é«˜æ€§èƒ½ã€å®‰å…¨å¯é çš„æ··åˆå¼Web3é‡‘èå¹³å°ï¼Œæ”¯æŒç™¾ä¸‡çº§ç”¨æˆ·å¹¶å‘ä½¿ç”¨

---

## 1. ğŸ¯ æ•´ä½“æ¶æ„æ¦‚è§ˆ

### ç³»ç»Ÿæ¶æ„å›¾
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    å®¢æˆ·ç«¯å±‚                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Next.js Frontend  â”‚  Mobile App  â”‚  Admin Dashboard    â”‚
â”‚  (React + TS)      â”‚  (React Native) â”‚  (React + TS)    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ç½‘å…³å±‚                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚        NGINX + Cloudflare CDN + Rate Limiting          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   åº”ç”¨æœåŠ¡å±‚                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  NestJS API Gateway â”‚ Auth Service â”‚ Business Services   â”‚
â”‚  GraphQL + REST     â”‚ JWT + RBAC   â”‚ User/Product/Order  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   æ•°æ®å­˜å‚¨å±‚                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  PostgreSQL  â”‚    Redis      â”‚   S3/R2    â”‚  Blockchain  â”‚
â”‚  (ä¸»æ•°æ®åº“)   â”‚  (ç¼“å­˜+é˜Ÿåˆ—)   â”‚  (æ–‡ä»¶å­˜å‚¨) â”‚  (åˆçº¦æ•°æ®)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   åŸºç¡€è®¾æ–½å±‚                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     Docker + Kubernetes + AWS/Vercel + Monitoring       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ ¸å¿ƒæŠ€æœ¯æ ˆ
```typescript
// å‰ç«¯æŠ€æœ¯æ ˆ
const frontendStack = {
  framework: 'Next.js 14',
  language: 'TypeScript 5.0',
  styling: 'Tailwind CSS + shadcn/ui',
  stateManagement: 'Zustand + TanStack Query',
  web3: 'wagmi + viem + RainbowKit',
  testing: 'Jest + Playwright',
  deployment: 'Vercel'
};

// åç«¯æŠ€æœ¯æ ˆ
const backendStack = {
  framework: 'NestJS',
  language: 'TypeScript 5.0', 
  database: 'PostgreSQL + Prisma',
  cache: 'Redis + ioredis',
  queue: 'BullMQ',
  auth: 'JWT + Passport',
  api: 'GraphQL + REST',
  deployment: 'Docker + AWS ECS'
};

// Web3æŠ€æœ¯æ ˆ
const web3Stack = {
  contracts: 'Solidity + Hardhat',
  network: 'Polygon + Arbitrum',
  indexing: 'The Graph',
  storage: 'IPFS + Arweave',
  oracles: 'Chainlink',
  monitoring: 'Tenderly'
};
```

---

## 2. ğŸ“Š æ•°æ®åº“æ¶æ„è®¾è®¡

### æ ¸å¿ƒè¡¨ç»“æ„ä¼˜åŒ–
```sql
-- ç”¨æˆ·è¡¨ (åˆ†åŒºè¡¨)
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    uuid VARCHAR(36) UNIQUE NOT NULL DEFAULT gen_random_uuid(),
    email VARCHAR(255) UNIQUE,
    password_hash VARCHAR(255),
    role user_role DEFAULT 'USER',
    referral_code VARCHAR(20) UNIQUE NOT NULL,
    referred_by_id INTEGER REFERENCES users(id),
    agent_id INTEGER REFERENCES users(id),
    kyc_status kyc_status DEFAULT 'PENDING',
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
) PARTITION BY RANGE (created_at);

-- æŒ‰æœˆåˆ†åŒº
CREATE TABLE users_2024_01 PARTITION OF users 
FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

-- é’±åŒ…è¡¨ (æ”¯æŒå¤šé“¾)
CREATE TABLE wallets (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id),
    chain_id INTEGER NOT NULL,
    address VARCHAR(42) NOT NULL,
    is_primary BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT NOW(),
    UNIQUE(chain_id, address)
);

-- äº§å“è¡¨ (æ”¯æŒåŠ¨æ€é…ç½®)
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    uuid VARCHAR(36) UNIQUE NOT NULL DEFAULT gen_random_uuid(),
    symbol VARCHAR(20) NOT NULL, -- SILVER/GOLD/DIAMOND
    name VARCHAR(100) NOT NULL,
    description TEXT,
    min_amount DECIMAL(20,6) NOT NULL,
    max_amount DECIMAL(20,6),
    apr_bps INTEGER NOT NULL, -- åŸºç‚¹è¡¨ç¤ºï¼Œä¾¿äºç²¾ç¡®è®¡ç®—
    lock_days INTEGER NOT NULL,
    nft_token_id INTEGER UNIQUE,
    nft_metadata JSONB, -- NFTå…ƒæ•°æ®
    is_active BOOLEAN DEFAULT TRUE,
    starts_at TIMESTAMP NOT NULL,
    ends_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT NOW()
);

-- è®¢å•è¡¨ (é«˜é¢‘å†™å…¥ï¼Œéœ€è¦ä¼˜åŒ–)
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    uuid VARCHAR(36) UNIQUE NOT NULL DEFAULT gen_random_uuid(),
    user_id INTEGER NOT NULL REFERENCES users(id),
    product_id INTEGER NOT NULL REFERENCES products(id),
    usdt_amount DECIMAL(20,6) NOT NULL,
    platform_fee DECIMAL(20,6) DEFAULT 0,
    tx_hash VARCHAR(66), -- ä»¥å¤ªåŠäº¤æ˜“å“ˆå¸Œ
    status order_status DEFAULT 'PENDING',
    referrer_id INTEGER REFERENCES users(id),
    agent_id INTEGER REFERENCES users(id),
    created_at TIMESTAMP DEFAULT NOW(),
    confirmed_at TIMESTAMP,
    INDEX idx_orders_user_status (user_id, status),
    INDEX idx_orders_tx_hash (tx_hash),
    INDEX idx_orders_created_at (created_at)
);

-- æŒä»“è¡¨ (ä¸NFTä¸€å¯¹ä¸€)
CREATE TABLE positions (
    id SERIAL PRIMARY KEY,
    uuid VARCHAR(36) UNIQUE NOT NULL DEFAULT gen_random_uuid(),
    user_id INTEGER NOT NULL REFERENCES users(id),
    product_id INTEGER NOT NULL REFERENCES products(id),
    order_id INTEGER NOT NULL REFERENCES orders(id),
    principal DECIMAL(20,6) NOT NULL,
    start_date DATE NOT NULL,
    end_date DATE NOT NULL,
    next_payout_at TIMESTAMP,
    nft_token_id INTEGER,
    nft_token_uri VARCHAR(500),
    status position_status DEFAULT 'ACTIVE',
    created_at TIMESTAMP DEFAULT NOW(),
    INDEX idx_positions_user_status (user_id, status),
    INDEX idx_positions_next_payout (next_payout_at),
    INDEX idx_positions_end_date (end_date)
);

-- æ”¶ç›Šåˆ†å‘è¡¨ (åˆ†åŒºè¡¨ï¼Œé«˜é¢‘æŸ¥è¯¢)
CREATE TABLE payouts (
    id SERIAL PRIMARY KEY,
    uuid VARCHAR(36) UNIQUE NOT NULL DEFAULT gen_random_uuid(),
    user_id INTEGER NOT NULL REFERENCES users(id),
    position_id INTEGER NOT NULL REFERENCES positions(id),
    amount DECIMAL(20,6) NOT NULL,
    period_start DATE NOT NULL,
    period_end DATE NOT NULL,
    is_claimable BOOLEAN DEFAULT FALSE,
    claimed_at TIMESTAMP,
    claim_tx_hash VARCHAR(66),
    merkle_index INTEGER, -- Merkleæ ‘ç´¢å¼•
    merkle_proof JSONB,   -- Merkleè¯æ˜
    batch_id VARCHAR(36),  -- æ‰¹æ¬¡ID
    created_at TIMESTAMP DEFAULT NOW()
) PARTITION BY RANGE (period_start);

-- ä½£é‡‘è¡¨ (åˆ†åŒºè¡¨)
CREATE TABLE commissions (
    id SERIAL PRIMARY KEY,
    uuid VARCHAR(36) UNIQUE NOT NULL DEFAULT gen_random_uuid(),
    user_id INTEGER NOT NULL REFERENCES users(id),
    order_id INTEGER NOT NULL REFERENCES orders(id),
    basis_amount DECIMAL(20,6) NOT NULL, -- è®¡ç®—åŸºæ•°
    rate_bps INTEGER NOT NULL, -- ä½£é‡‘æ¯”ä¾‹(åŸºç‚¹)
    amount DECIMAL(20,6) NOT NULL,
    commission_type commission_type NOT NULL, -- REFERRAL/AGENT
    status commission_status DEFAULT 'PENDING',
    settled_at TIMESTAMP,
    settlement_tx_hash VARCHAR(66),
    created_at TIMESTAMP DEFAULT NOW()
) PARTITION BY RANGE (created_at);

-- å®¡è®¡æ—¥å¿—è¡¨ (æ—¶åºæ•°æ®åº“é£æ ¼)
CREATE TABLE audit_logs (
    id SERIAL PRIMARY KEY,
    actor_id INTEGER REFERENCES users(id),
    actor_type VARCHAR(20) DEFAULT 'USER',
    action VARCHAR(50) NOT NULL,
    resource_type VARCHAR(50),
    resource_id VARCHAR(36),
    ip_address INET,
    user_agent TEXT,
    metadata JSONB,
    created_at TIMESTAMP DEFAULT NOW(),
    INDEX idx_audit_logs_actor (actor_id, created_at),
    INDEX idx_audit_logs_action (action, created_at),
    INDEX idx_audit_logs_resource (resource_type, resource_id)
);
```

### æ•°æ®åº“æ€§èƒ½ä¼˜åŒ–
```sql
-- åˆ›å»ºæšä¸¾ç±»å‹
CREATE TYPE user_role AS ENUM ('USER', 'AGENT', 'ADMIN');
CREATE TYPE kyc_status AS ENUM ('PENDING', 'APPROVED', 'REJECTED');
CREATE TYPE order_status AS ENUM ('PENDING', 'SUCCESS', 'FAILED', 'CANCELED');
CREATE TYPE position_status AS ENUM ('ACTIVE', 'REDEEMING', 'CLOSED', 'DEFAULTED');
CREATE TYPE commission_type AS ENUM ('REFERRAL', 'AGENT');
CREATE TYPE commission_status AS ENUM ('PENDING', 'READY', 'PAID', 'FAILED');

-- åˆ›å»ºå¤åˆç´¢å¼•
CREATE INDEX CONCURRENTLY idx_orders_user_product_status 
ON orders (user_id, product_id, status, created_at);

CREATE INDEX CONCURRENTLY idx_positions_user_active 
ON positions (user_id, status) WHERE status = 'ACTIVE';

CREATE INDEX CONCURRENTLY idx_payouts_claimable 
ON payouts (user_id, is_claimable, created_at) WHERE is_claimable = TRUE;

-- åˆ›å»ºå‡½æ•°ç´¢å¼•
CREATE INDEX CONCURRENTLY idx_users_referral_code_lower 
ON users (LOWER(referral_code));

-- åˆ›å»ºéƒ¨åˆ†ç´¢å¼•
CREATE INDEX CONCURRENTLY idx_orders_pending 
ON orders (created_at) WHERE status = 'PENDING';

-- åˆ›å»ºGINç´¢å¼•æ”¯æŒJSONBæŸ¥è¯¢
CREATE INDEX CONCURRENTLY idx_audit_logs_metadata_gin 
ON audit_logs USING GIN (metadata);
```

### æ•°æ®åº“è¿æ¥æ± é…ç½®
```typescript
// prisma/schema.prisma ä¼˜åŒ–é…ç½®
generator client {
  provider = "prisma-client-js"
  previewFeatures = ["multiSchema", "views", "fullTextSearch"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

// è¿æ¥æ± é…ç½®
const prisma = new PrismaClient({
  datasources: {
    db: {
      url: process.env.DATABASE_URL + '?connection_limit=20&pool_timeout=20'
    }
  },
  log: process.env.NODE_ENV === 'development' 
    ? ['query', 'info', 'warn', 'error']
    : ['error']
});

// è¯»å†™åˆ†ç¦»é…ç½®
const readReplica = new PrismaClient({
  datasources: {
    db: { url: process.env.DATABASE_READ_URL }
  }
});
```

---

## 3. ğŸ”Œ API æ¥å£è®¾è®¡

### RESTful API è§„èŒƒ
```typescript
// APIè·¯ç”±ç»“æ„
const apiRoutes = {
  // è®¤è¯ç›¸å…³
  auth: {
    'POST /auth/register': 'ç”¨æˆ·æ³¨å†Œ',
    'POST /auth/login': 'ç”¨æˆ·ç™»å½•',
    'POST /auth/refresh': 'åˆ·æ–°Token',
    'POST /auth/logout': 'ç”¨æˆ·ç™»å‡º',
    'POST /auth/wallet': 'é’±åŒ…è¿æ¥è®¤è¯'
  },
  
  // ç”¨æˆ·ç›¸å…³
  users: {
    'GET /users/me': 'è·å–ç”¨æˆ·ä¿¡æ¯',
    'PUT /users/me': 'æ›´æ–°ç”¨æˆ·ä¿¡æ¯',
    'GET /users/me/wallets': 'è·å–ç”¨æˆ·é’±åŒ…',
    'POST /users/me/wallets': 'æ·»åŠ é’±åŒ…åœ°å€',
    'DELETE /users/me/wallets/:id': 'åˆ é™¤é’±åŒ…åœ°å€'
  },
  
  // äº§å“ç›¸å…³
  products: {
    'GET /products': 'è·å–äº§å“åˆ—è¡¨',
    'GET /products/:id': 'è·å–äº§å“è¯¦æƒ…',
    'GET /products/:id/stats': 'è·å–äº§å“ç»Ÿè®¡ä¿¡æ¯'
  },
  
  // è®¢å•ç›¸å…³
  orders: {
    'POST /orders/draft': 'åˆ›å»ºè®¢å•è‰ç¨¿',
    'POST /orders': 'åˆ›å»ºè®¢å•',
    'GET /orders': 'è·å–è®¢å•åˆ—è¡¨',
    'GET /orders/:id': 'è·å–è®¢å•è¯¦æƒ…',
    'POST /orders/:id/confirm': 'ç¡®è®¤è®¢å•'
  },
  
  // æŒä»“ç›¸å…³
  positions: {
    'GET /positions': 'è·å–æŒä»“åˆ—è¡¨',
    'GET /positions/:id': 'è·å–æŒä»“è¯¦æƒ…',
    'GET /positions/summary': 'è·å–æŒä»“æ±‡æ€»'
  },
  
  // æ”¶ç›Šç›¸å…³
  payouts: {
    'GET /payouts': 'è·å–æ”¶ç›Šè®°å½•',
    'GET /payouts/claimable': 'è·å–å¯é¢†å–æ”¶ç›Š',
    'POST /payouts/prepare-claim': 'å‡†å¤‡é¢†å–æ”¶ç›Š',
    'POST /payouts/claim': 'é¢†å–æ”¶ç›Š'
  },
  
  // æ¨èç›¸å…³
  referral: {
    'GET /referral/stats': 'è·å–æ¨èç»Ÿè®¡',
    'POST /referral/link': 'ç”Ÿæˆæ¨èé“¾æ¥',
    'GET /referral/commissions': 'è·å–ä½£é‡‘è®°å½•'
  }
};
```

### GraphQL Schema è®¾è®¡
```graphql
type User {
  id: ID!
  email: String
  role: UserRole!
  referralCode: String!
  wallets: [Wallet!]!
  positions: [Position!]!
  totalInvestment: Float!
  totalRevenue: Float!
  claimableAmount: Float!
  referralStats: ReferralStats
  createdAt: DateTime!
}

type Product {
  id: ID!
  symbol: String!
  name: String!
  description: String
  minAmount: Float!
  maxAmount: Float
  apr: Float!
  lockDays: Int!
  nftTokenId: Int
  isActive: Boolean!
  stats: ProductStats
}

type Position {
  id: ID!
  user: User!
  product: Product!
  principal: Float!
  startDate: Date!
  endDate: Date!
  nextPayoutAt: DateTime
  status: PositionStatus!
  nftTokenId: Int
  expectedRevenue: Float!
  actualRevenue: Float!
  payouts: [Payout!]!
}

type Payout {
  id: ID!
  position: Position!
  amount: Float!
  periodStart: Date!
  periodEnd: Date!
  isClaimable: Boolean!
  claimedAt: DateTime
  claimTxHash: String
}

type ReferralStats {
  totalReferrals: Int!
  successfulReferrals: Int!
  totalCommission: Float!
  pendingCommission: Float!
}

type Query {
  me: User
  products(filter: ProductFilter): [Product!]!
  positions(filter: PositionFilter): [Position!]!
  payouts(filter: PayoutFilter): [Payout!]!
  referralStats: ReferralStats
}

type Mutation {
  register(input: RegisterInput!): AuthPayload!
  login(input: LoginInput!): AuthPayload!
  connectWallet(input: WalletInput!): User!
  createOrder(input: OrderInput!): Order!
  claimPayouts(positionIds: [ID!]!): ClaimResult!
}

type Subscription {
  orderStatusChanged(userId: ID!): Order!
  payoutDistributed(userId: ID!): Payout!
  priceUpdated(productId: ID!): Product!
}
```

### APIå“åº”æ ¼å¼æ ‡å‡†
```typescript
// ç»Ÿä¸€å“åº”æ ¼å¼
interface ApiResponse<T = any> {
  success: boolean;
  data?: T;
  error?: {
    code: string;
    message: string;
    details?: any;
  };
  meta?: {
    requestId: string;
    timestamp: number;
    version: string;
  };
}

// åˆ†é¡µå“åº”æ ¼å¼
interface PaginatedResponse<T> extends ApiResponse<T[]> {
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };
}

// å®é™…å“åº”ç¤ºä¾‹
const successResponse: ApiResponse<Product[]> = {
  success: true,
  data: [
    {
      id: '1',
      symbol: 'SILVER',
      name: 'é“¶å¡',
      minAmount: 100,
      apr: 12,
      lockDays: 365
    }
  ],
  meta: {
    requestId: 'req_1234567890',
    timestamp: Date.now(),
    version: '1.0.0'
  }
};

const errorResponse: ApiResponse = {
  success: false,
  error: {
    code: 'INSUFFICIENT_BALANCE',
    message: 'ä½™é¢ä¸è¶³',
    details: {
      required: 1000,
      available: 500
    }
  },
  meta: {
    requestId: 'req_1234567890',
    timestamp: Date.now(),
    version: '1.0.0'
  }
};
```

---

## 4. ğŸ” è®¤è¯ä¸æƒé™ç³»ç»Ÿ

### JWT + RBACå®ç°
```typescript
// JWT Payload ç»“æ„
interface JwtPayload {
  sub: string; // ç”¨æˆ·ID
  email: string;
  role: UserRole;
  permissions: string[];
  wallets: string[]; // å…³è”çš„é’±åŒ…åœ°å€
  iat: number;
  exp: number;
}

// æƒé™å®šä¹‰
const PERMISSIONS = {
  // ç”¨æˆ·æƒé™
  'user:read': 'è¯»å–ç”¨æˆ·ä¿¡æ¯',
  'user:update': 'æ›´æ–°ç”¨æˆ·ä¿¡æ¯',
  'wallet:connect': 'è¿æ¥é’±åŒ…',
  'order:create': 'åˆ›å»ºè®¢å•',
  'payout:claim': 'é¢†å–æ”¶ç›Š',
  
  // ä»£ç†æƒé™
  'agent:stats': 'æŸ¥çœ‹ä»£ç†ç»Ÿè®¡',
  'agent:team': 'ç®¡ç†å›¢é˜Ÿ',
  'commission:view': 'æŸ¥çœ‹ä½£é‡‘',
  
  // ç®¡ç†å‘˜æƒé™
  'admin:users': 'ç”¨æˆ·ç®¡ç†',
  'admin:products': 'äº§å“ç®¡ç†',
  'admin:settlement': 'ç»“ç®—ç®¡ç†',
  'admin:system': 'ç³»ç»Ÿç®¡ç†'
};

// è§’è‰²æƒé™æ˜ å°„
const ROLE_PERMISSIONS = {
  USER: [
    'user:read', 'user:update', 'wallet:connect',
    'order:create', 'payout:claim'
  ],
  AGENT: [
    ...ROLE_PERMISSIONS.USER,
    'agent:stats', 'agent:team', 'commission:view'
  ],
  ADMIN: [
    ...ROLE_PERMISSIONS.AGENT,
    'admin:users', 'admin:products', 
    'admin:settlement', 'admin:system'
  ]
};
```

### Web3ç­¾åè®¤è¯
```typescript
// Web3ç™»å½•æµç¨‹
@Controller('auth')
export class AuthController {
  @Post('wallet/challenge')
  async getChallenge(@Body() { address }: { address: string }) {
    const nonce = randomBytes(32).toString('hex');
    const message = `Sign this message to authenticate: ${nonce}`;
    
    // ç¼“å­˜challengeä¿¡æ¯
    await this.redis.setex(`auth:${address}`, 300, nonce);
    
    return { message, nonce };
  }

  @Post('wallet/verify')
  async verifySignature(@Body() body: WalletAuthDto) {
    const { address, signature, message } = body;
    
    // éªŒè¯ç­¾å
    const recoveredAddress = verifyMessage(message, signature);
    if (recoveredAddress.toLowerCase() !== address.toLowerCase()) {
      throw new UnauthorizedException('Invalid signature');
    }
    
    // æŸ¥æ‰¾æˆ–åˆ›å»ºç”¨æˆ·
    let user = await this.userService.findByWallet(address);
    if (!user) {
      user = await this.userService.createFromWallet(address);
    }
    
    // ç”ŸæˆJWT
    const tokens = await this.authService.generateTokens(user);
    return tokens;
  }
}

// ç­¾åéªŒè¯å·¥å…·
function verifyMessage(message: string, signature: string): string {
  const messageHash = hashMessage(message);
  const recoveredAddress = recoverAddress(messageHash, signature);
  return recoveredAddress;
}
```

---

## 5. âš¡ å®æ—¶æ•°æ®åŒæ­¥

### WebSocketå®ç°
```typescript
// WebSocketç½‘å…³
@WebSocketGateway({
  cors: { origin: process.env.FRONTEND_URL },
  namespace: 'app'
})
export class AppGateway implements OnGatewayConnection, OnGatewayDisconnect {
  @WebSocketServer() server: Server;
  
  private userSockets = new Map<string, Socket>();

  async handleConnection(client: Socket) {
    try {
      const token = client.handshake.auth.token;
      const payload = await this.authService.verifyToken(token);
      
      client.data.userId = payload.sub;
      this.userSockets.set(payload.sub, client);
      
      // åŠ å…¥ç”¨æˆ·æˆ¿é—´
      client.join(`user:${payload.sub}`);
      
      // å‘é€åˆå§‹æ•°æ®
      await this.sendUserStats(payload.sub);
      
    } catch (error) {
      client.disconnect();
    }
  }

  handleDisconnect(client: Socket) {
    const userId = client.data.userId;
    if (userId) {
      this.userSockets.delete(userId);
    }
  }

  // è®¢å•çŠ¶æ€æ›´æ–°
  async notifyOrderStatus(userId: string, order: Order) {
    this.server.to(`user:${userId}`).emit('order:status', {
      orderId: order.id,
      status: order.status,
      txHash: order.txHash
    });
  }

  // æ”¶ç›Šåˆ†å‘é€šçŸ¥
  async notifyPayoutDistributed(userId: string, payout: Payout) {
    this.server.to(`user:${userId}`).emit('payout:distributed', {
      amount: payout.amount,
      positionId: payout.positionId,
      claimable: payout.isClaimable
    });
  }

  // ä»·æ ¼æ›´æ–°æ¨é€
  @SubscribeMessage('subscribe:prices')
  async handlePriceSubscription(client: Socket, productIds: string[]) {
    for (const productId of productIds) {
      client.join(`prices:${productId}`);
    }
  }
}
```

### åŒºå—é“¾äº‹ä»¶ç›‘å¬
```typescript
// åŒºå—é“¾äº‹ä»¶ç›‘å¬æœåŠ¡
@Injectable()
export class BlockchainListenerService {
  private providers: Map<number, ethers.Provider> = new Map();
  private contracts: Map<string, ethers.Contract> = new Map();

  async onModuleInit() {
    // åˆå§‹åŒ–å¤šé“¾æ”¯æŒ
    this.setupProviders();
    this.setupContracts();
    this.startEventListening();
  }

  private setupProviders() {
    const chains = [137, 42161]; // Polygon, Arbitrum
    
    chains.forEach(chainId => {
      const rpcUrl = process.env[`RPC_URL_${chainId}`];
      const provider = new ethers.JsonRpcProvider(rpcUrl);
      this.providers.set(chainId, provider);
    });
  }

  private async startEventListening() {
    // ç›‘å¬USDTå­˜æ¬¾äº‹ä»¶
    const treasuryContract = this.contracts.get('treasury');
    treasuryContract.on('Deposited', async (user, amount, txHash) => {
      await this.handleDeposit(user, amount, txHash);
    });

    // ç›‘å¬NFTé“¸é€ äº‹ä»¶
    const nftContract = this.contracts.get('nft');
    nftContract.on('TransferSingle', async (operator, from, to, id, value) => {
      if (from === ethers.ZeroAddress) {
        await this.handleNFTMinted(to, id, value);
      }
    });

    // ç›‘å¬æ”¶ç›Šåˆ†å‘äº‹ä»¶
    const distributorContract = this.contracts.get('distributor');
    distributorContract.on('Claimed', async (user, amount, merkleIndex) => {
      await this.handlePayoutClaimed(user, amount, merkleIndex);
    });
  }

  private async handleDeposit(user: string, amount: bigint, txHash: string) {
    try {
      // æŸ¥æ‰¾å¾…ç¡®è®¤çš„è®¢å•
      const order = await this.orderService.findPendingByTxHash(txHash);
      if (!order) return;

      // ç¡®è®¤è®¢å•
      await this.orderService.confirmOrder(order.id, {
        status: 'SUCCESS',
        confirmedAt: new Date()
      });

      // åˆ›å»ºæŒä»“
      await this.positionService.createFromOrder(order);

      // é“¸é€ NFT
      await this.nftService.mint(user, order.productId);

      // é€šçŸ¥å‰ç«¯
      await this.appGateway.notifyOrderStatus(order.userId, order);

    } catch (error) {
      this.logger.error('Failed to handle deposit', error);
    }
  }
}
```

---

## 6. ğŸš€ æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### ç¼“å­˜ç­–ç•¥
```typescript
// Redisç¼“å­˜é…ç½®
@Injectable()
export class CacheService {
  constructor(
    @InjectRedis() private redis: Redis,
    private configService: ConfigService
  ) {}

  // äº§å“ä¿¡æ¯ç¼“å­˜ (é•¿æœŸç¼“å­˜)
  async getProduct(id: string): Promise<Product | null> {
    const cacheKey = `product:${id}`;
    const cached = await this.redis.get(cacheKey);
    
    if (cached) {
      return JSON.parse(cached);
    }

    const product = await this.productService.findById(id);
    if (product) {
      await this.redis.setex(cacheKey, 3600 * 24, JSON.stringify(product));
    }
    
    return product;
  }

  // ç”¨æˆ·ç»Ÿè®¡ä¿¡æ¯ç¼“å­˜ (çŸ­æœŸç¼“å­˜)
  async getUserStats(userId: string): Promise<UserStats> {
    const cacheKey = `user:stats:${userId}`;
    const cached = await this.redis.get(cacheKey);
    
    if (cached) {
      return JSON.parse(cached);
    }

    const stats = await this.userService.calculateStats(userId);
    await this.redis.setex(cacheKey, 300, JSON.stringify(stats)); // 5åˆ†é’Ÿç¼“å­˜
    
    return stats;
  }

  // çƒ­é—¨æ•°æ®é¢„çƒ­
  async warmupCache() {
    const activeProducts = await this.productService.findActive();
    const promises = activeProducts.map(product => 
      this.getProduct(product.id)
    );
    
    await Promise.all(promises);
    this.logger.log(`Warmed up ${activeProducts.length} products`);
  }
}
```

### æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–
```typescript
// å¤æ‚æŸ¥è¯¢ä¼˜åŒ–
@Injectable()
export class PositionService {
  // ä½¿ç”¨åŸç”ŸSQLä¼˜åŒ–å¤æ‚ç»Ÿè®¡æŸ¥è¯¢
  async getUserPositionStats(userId: string): Promise<PositionStats> {
    const result = await this.prisma.$queryRaw<PositionStatsRaw[]>`
      SELECT 
        COUNT(*) as total_positions,
        SUM(principal) as total_investment,
        SUM(
          CASE 
            WHEN status = 'ACTIVE' THEN principal * (products.apr_bps / 10000.0) * 
                 (EXTRACT(days FROM (LEAST(NOW(), end_date) - start_date)) / 365.0)
            ELSE 0 
          END
        ) as expected_revenue,
        COUNT(CASE WHEN status = 'ACTIVE' THEN 1 END) as active_positions,
        COUNT(CASE WHEN status = 'CLOSED' THEN 1 END) as closed_positions
      FROM positions p
      JOIN products ON p.product_id = products.id  
      WHERE p.user_id = ${userId}
    `;

    return this.transformPositionStats(result[0]);
  }

  // æ‰¹é‡æŸ¥è¯¢ä¼˜åŒ–
  async findUserPositionsWithPayouts(userId: string): Promise<PositionWithPayouts[]> {
    return await this.prisma.position.findMany({
      where: { userId },
      include: {
        product: {
          select: {
            name: true,
            symbol: true,
            aprBps: true
          }
        },
        payouts: {
          where: { isClaimable: true },
          select: {
            id: true,
            amount: true,
            periodStart: true,
            periodEnd: true
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    });
  }
}
```

### APIæ€§èƒ½ä¼˜åŒ–
```typescript
// å“åº”æ—¶é—´ä¸­é—´ä»¶
@Injectable()
export class PerformanceMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: NextFunction) {
    const start = Date.now();
    
    res.on('finish', () => {
      const duration = Date.now() - start;
      
      // è®°å½•æ…¢æŸ¥è¯¢
      if (duration > 1000) {
        console.warn(`Slow request: ${req.method} ${req.url} took ${duration}ms`);
      }
      
      // è®¾ç½®æ€§èƒ½å¤´éƒ¨
      res.set('X-Response-Time', `${duration}ms`);
    });
    
    next();
  }
}

// æŸ¥è¯¢ç»“æœå‹ç¼©
@Controller()
export class BaseController {
  @Get('products')
  @UseInterceptors(CacheInterceptor)
  @Header('Cache-Control', 'public, max-age=3600')
  async getProducts(@Query() query: ProductQueryDto) {
    const products = await this.productService.findMany(query);
    
    // è¿”å›æ—¶å»é™¤ä¸å¿…è¦çš„å­—æ®µ
    return products.map(product => ({
      id: product.id,
      symbol: product.symbol,
      name: product.name,
      minAmount: product.minAmount,
      apr: product.aprBps / 100,
      lockDays: product.lockDays,
      isActive: product.isActive
    }));
  }
}
```

---

## 7. ğŸ”’ å®‰å…¨é˜²æŠ¤æªæ–½

### APIå®‰å…¨é˜²æŠ¤
```typescript
// é€Ÿç‡é™åˆ¶é…ç½®
const rateLimitConfig = {
  // å…¨å±€é™åˆ¶
  global: {
    windowMs: 15 * 60 * 1000, // 15åˆ†é’Ÿ
    max: 1000 // æ¯ä¸ªIPæœ€å¤š1000æ¬¡è¯·æ±‚
  },
  
  // ç™»å½•æ¥å£é™åˆ¶
  auth: {
    windowMs: 15 * 60 * 1000,
    max: 5, // æ¯15åˆ†é’Ÿæœ€å¤š5æ¬¡ç™»å½•å°è¯•
    skipSuccessfulRequests: true
  },
  
  // è®¢å•åˆ›å»ºé™åˆ¶
  orders: {
    windowMs: 60 * 1000, // 1åˆ†é’Ÿ
    max: 10, // æ¯åˆ†é’Ÿæœ€å¤š10ä¸ªè®¢å•
    keyGenerator: (req) => req.user?.id || req.ip
  }
};

// è¾“å…¥éªŒè¯å’Œæ¶ˆæ¯’
@Controller('orders')
export class OrderController {
  @Post()
  @UseGuards(JwtAuthGuard, ThrottlerGuard)
  @Throttle(10, 60) // æ¯åˆ†é’Ÿæœ€å¤š10æ¬¡
  async createOrder(
    @Body() dto: CreateOrderDto,
    @CurrentUser() user: User
  ) {
    // æ•°æ®éªŒè¯
    await this.validateOrderData(dto, user);
    
    // ä¸šåŠ¡è§„åˆ™æ£€æŸ¥
    await this.checkBusinessRules(dto, user);
    
    // åˆ›å»ºè®¢å•
    return await this.orderService.create(dto, user);
  }

  private async validateOrderData(dto: CreateOrderDto, user: User) {
    // æ£€æŸ¥ç”¨æˆ·KYCçŠ¶æ€
    if (user.kycStatus !== 'APPROVED') {
      throw new ForbiddenException('KYC verification required');
    }

    // æ£€æŸ¥æŠ•èµ„é™é¢
    const dailyLimit = await this.userService.getDailyLimit(user.id);
    if (dto.amount > dailyLimit) {
      throw new BadRequestException('Amount exceeds daily limit');
    }

    // æ£€æŸ¥äº§å“æœ‰æ•ˆæ€§
    const product = await this.productService.findById(dto.productId);
    if (!product || !product.isActive) {
      throw new BadRequestException('Product not available');
    }
  }
}
```

### SQLæ³¨å…¥é˜²æŠ¤
```typescript
// å‚æ•°åŒ–æŸ¥è¯¢
@Injectable()
export class UserService {
  // âœ… å®‰å…¨çš„æŸ¥è¯¢æ–¹å¼
  async findByEmail(email: string): Promise<User | null> {
    return await this.prisma.user.findUnique({
      where: { email: email.toLowerCase().trim() }
    });
  }

  // âœ… ä½¿ç”¨Prismaçš„ç±»å‹å®‰å…¨æŸ¥è¯¢
  async searchUsers(query: string, limit: number = 20): Promise<User[]> {
    return await this.prisma.user.findMany({
      where: {
        OR: [
          { email: { contains: query, mode: 'insensitive' } },
          { referralCode: { contains: query, mode: 'insensitive' } }
        ]
      },
      take: Math.min(limit, 100), // é™åˆ¶ç»“æœæ•°é‡
      select: {
        id: true,
        email: true,
        referralCode: true,
        createdAt: true
      }
    });
  }

  // âœ… å¤æ‚æŸ¥è¯¢ä½¿ç”¨å‚æ•°åŒ–åŸç”ŸSQL
  async getRevenueStats(userId: string, startDate: Date, endDate: Date) {
    return await this.prisma.$queryRaw`
      SELECT 
        DATE(created_at) as date,
        SUM(amount) as daily_revenue
      FROM payouts 
      WHERE user_id = ${userId}
        AND created_at >= ${startDate}
        AND created_at <= ${endDate}
        AND claimed_at IS NOT NULL
      GROUP BY DATE(created_at)
      ORDER BY date ASC
    `;
  }
}
```

### æ•°æ®åŠ å¯†å­˜å‚¨
```typescript
// æ•æ„Ÿæ•°æ®åŠ å¯†
@Injectable()
export class EncryptionService {
  private readonly algorithm = 'aes-256-gcm';
  private readonly keyLength = 32;

  constructor(private configService: ConfigService) {}

  encrypt(text: string): string {
    const key = Buffer.from(this.configService.get('ENCRYPTION_KEY'), 'hex');
    const iv = randomBytes(16);
    const cipher = createCipher(this.algorithm, key);
    cipher.setAAD(Buffer.from('additional-data'));
    
    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    
    const authTag = cipher.getAuthTag();
    
    return `${iv.toString('hex')}:${authTag.toString('hex')}:${encrypted}`;
  }

  decrypt(encryptedData: string): string {
    const [ivHex, authTagHex, encrypted] = encryptedData.split(':');
    const key = Buffer.from(this.configService.get('ENCRYPTION_KEY'), 'hex');
    const iv = Buffer.from(ivHex, 'hex');
    const authTag = Buffer.from(authTagHex, 'hex');
    
    const decipher = createDecipher(this.algorithm, key);
    decipher.setAAD(Buffer.from('additional-data'));
    decipher.setAuthTag(authTag);
    
    let decrypted = decipher.update(encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    
    return decrypted;
  }
}

// ä½¿ç”¨ç¤ºä¾‹
@Entity('sensitive_data')
export class SensitiveData {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  userId: number;

  @Column({ transformer: new EncryptedTransformer() })
  personalInfo: string; // è‡ªåŠ¨åŠ å¯†å­˜å‚¨

  @Column({ transformer: new EncryptedTransformer() })
  kycDocuments: string; // è‡ªåŠ¨åŠ å¯†å­˜å‚¨
}
```

---

## 8. ğŸ“Š ç›‘æ§ä¸æ—¥å¿—ç³»ç»Ÿ

### åº”ç”¨ç›‘æ§
```typescript
// å¥åº·æ£€æŸ¥ç«¯ç‚¹
@Controller('health')
export class HealthController {
  constructor(
    @InjectRedis() private redis: Redis,
    private prisma: PrismaService
  ) {}

  @Get()
  async check(): Promise<HealthStatus> {
    const checks = await Promise.allSettled([
      this.checkDatabase(),
      this.checkRedis(),
      this.checkBlockchain(),
      this.checkExternalServices()
    ]);

    const status = checks.every(check => check.status === 'fulfilled') 
      ? 'healthy' : 'unhealthy';

    return {
      status,
      timestamp: new Date().toISOString(),
      checks: {
        database: checks[0].status === 'fulfilled',
        redis: checks[1].status === 'fulfilled',
        blockchain: checks[2].status === 'fulfilled',
        external: checks[3].status === 'fulfilled'
      },
      uptime: process.uptime(),
      version: process.env.APP_VERSION
    };
  }

  private async checkDatabase(): Promise<void> {
    await this.prisma.$queryRaw`SELECT 1`;
  }

  private async checkRedis(): Promise<void> {
    await this.redis.ping();
  }

  private async checkBlockchain(): Promise<void> {
    const provider = new ethers.JsonRpcProvider(process.env.RPC_URL);
    await provider.getBlockNumber();
  }
}

// æ€§èƒ½ç›‘æ§ä¸­é—´ä»¶
@Injectable()
export class MetricsMiddleware implements NestMiddleware {
  private httpRequestDuration = new prometheus.Histogram({
    name: 'http_request_duration_seconds',
    help: 'Duration of HTTP requests in seconds',
    labelNames: ['method', 'route', 'status_code']
  });

  private httpRequestTotal = new prometheus.Counter({
    name: 'http_requests_total',
    help: 'Total number of HTTP requests',
    labelNames: ['method', 'route', 'status_code']
  });

  use(req: Request, res: Response, next: NextFunction) {
    const start = Date.now();
    
    res.on('finish', () => {
      const duration = (Date.now() - start) / 1000;
      const route = req.route?.path || req.url;
      
      this.httpRequestDuration
        .labels(req.method, route, res.statusCode.toString())
        .observe(duration);
        
      this.httpRequestTotal
        .labels(req.method, route, res.statusCode.toString())
        .inc();
    });
    
    next();
  }
}
```

### ç»“æ„åŒ–æ—¥å¿—
```typescript
// Winstonæ—¥å¿—é…ç½®
const loggerConfig = {
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json(),
    winston.format.printf(({ timestamp, level, message, stack, ...meta }) => {
      return JSON.stringify({
        timestamp,
        level,
        message,
        stack,
        ...meta,
        service: 'qa-app-backend',
        version: process.env.APP_VERSION
      });
    })
  ),
  transports: [
    new winston.transports.Console(),
    new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
    new winston.transports.File({ filename: 'logs/combined.log' })
  ]
};

// ä¸šåŠ¡äº‹ä»¶æ—¥å¿—
@Injectable()
export class AuditLogger {
  constructor(private logger: Logger) {}

  async logUserAction(
    userId: string, 
    action: string, 
    resource: string,
    metadata: any = {}
  ) {
    await this.prisma.auditLog.create({
      data: {
        actorId: parseInt(userId),
        action,
        resourceType: resource,
        metadata,
        ipAddress: metadata.ip,
        userAgent: metadata.userAgent
      }
    });

    this.logger.log({
      event: 'user_action',
      userId,
      action,
      resource,
      metadata
    });
  }

  async logSystemEvent(event: string, data: any) {
    this.logger.log({
      event: 'system_event',
      type: event,
      data
    });
  }
}
```

---

## ğŸ¯ **å®æ–½è®¡åˆ’**

### Phase 1: åŸºç¡€æ¶æ„æ­å»º (Week 1-2)
- [x] æŠ€æœ¯æ ˆé€‰å‹å’Œæ¶æ„è®¾è®¡
- [x] æ•°æ®åº“è®¾è®¡å’Œä¼˜åŒ–
- [ ] é¡¹ç›®è„šæ‰‹æ¶åˆ›å»º
- [ ] åŸºç¡€ä¸­é—´ä»¶å’Œå·¥å…·ç±»
- [ ] è®¤è¯æˆæƒç³»ç»Ÿ

### Phase 2: æ ¸å¿ƒåŠŸèƒ½å¼€å‘ (Week 3-6)
- [ ] ç”¨æˆ·ç®¡ç†å’Œé’±åŒ…è¿æ¥
- [ ] äº§å“ç®¡ç†å’Œè®¢å•å¤„ç†
- [ ] æŒä»“ç®¡ç†å’Œæ”¶ç›Šè®¡ç®—
- [ ] åŒºå—é“¾é›†æˆå’Œäº‹ä»¶ç›‘å¬
- [ ] å®æ—¶é€šä¿¡å’Œæ•°æ®åŒæ­¥

### Phase 3: é«˜çº§åŠŸèƒ½å®ç° (Week 7-10)
- [ ] æ¨èå¥–åŠ±ç³»ç»Ÿ
- [ ] ä»£ç†ç®¡ç†åå°
- [ ] æ‰¹é‡ç»“ç®—å’ŒMerkleåˆ†å‘
- [ ] ç®¡ç†å‘˜æ§åˆ¶å°
- [ ] é£æ§å’Œåˆè§„æ£€æŸ¥

### Phase 4: ä¼˜åŒ–ä¸éƒ¨ç½² (Week 11-12)
- [ ] æ€§èƒ½ä¼˜åŒ–å’Œå‹åŠ›æµ‹è¯•
- [ ] å®‰å…¨å®¡è®¡å’Œæ¼æ´ä¿®å¤
- [ ] ç›‘æ§å‘Šè­¦å’Œæ—¥å¿—å®Œå–„
- [ ] ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²
- [ ] æ–‡æ¡£å’ŒåŸ¹è®­

## ğŸš€ **æ¶æ„ä¼˜åŠ¿**

è¿™å¥—å…¨æ ˆæ¶æ„å°†æä¾›ï¼š

âœ¨ **é«˜æ€§èƒ½** - å¤šçº§ç¼“å­˜+æ•°æ®åº“ä¼˜åŒ–+CDNåŠ é€Ÿ  
âœ¨ **é«˜å¯ç”¨** - å¾®æœåŠ¡æ¶æ„+è´Ÿè½½å‡è¡¡+æ•…éšœæ¢å¤  
âœ¨ **é«˜å®‰å…¨** - å¤šå±‚é˜²æŠ¤+æ•°æ®åŠ å¯†+æƒé™æ§åˆ¶  
âœ¨ **é«˜æ‰©å±•** - æ¨ªå‘æ‰©å®¹+æ’ä»¶åŒ–+æ¨¡å—è§£è€¦  
âœ¨ **é«˜ç›‘æ§** - å…¨é“¾è·¯è¿½è¸ª+å®æ—¶å‘Šè­¦+æ€§èƒ½åˆ†æ  

å‡†å¤‡å¼€å§‹åˆ›å»ºé¡¹ç›®è„šæ‰‹æ¶äº†å—ï¼Ÿæˆ‘å°†ä¸ºæ‚¨æ„å»ºä¸€ä¸ªèƒ½å¤Ÿæ”¯æ’‘ç™¾ä¸‡ç”¨æˆ·çš„ä¼ä¸šçº§Web3å¹³å°ï¼ ğŸ—ï¸âœ¨